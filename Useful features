#### APPROXIMATION ####import mathimport numpy as npimport matplotlib.pyplot as plt%matplotlib inlinedef f(x):    return np.sin(x) + 0.5 * xx = np.linspace(-2 * np.pi, 2 * np.pi, 50)plt.grid(True)plt.xlabel('x')plt.ylabel('f(x)')plt.plot(x, f(x), 'b')#### REGRESSION ####reg = np.polyfit(x, f(x), deg=1)ry = np.polyval(reg, x)plt.plot(x, f(x), 'b', label='f(x)')plt.plot(x, ry, 'r.', label='regression')plt.legend(loc=0)plt.grid(True)plt.xlabel('x')plt.ylabel('f(x)')reg = np.polyfit(x, f(x), deg=5)ry = np.polyval(reg, x)plt.plot(x, f(x), 'b', label='f(x)')plt.plot(x, ry, 'r.', label='regression')plt.legend(loc=0)plt.grid(True)plt.xlabel('x')plt.ylabel('f(x)')reg = np.polyfit(x, f(x), 7)ry = np.polyval(reg, x)plt.plot(x, f(x), 'b', label='f(x)')plt.plot(x, ry, 'r.', label='regression')plt.legend(loc=0)plt.grid(True)plt.xlabel('x')plt.ylabel('f(x)')np.allclose(f(x), ry) #checks resultsnp.sum((f(x) - ry) ** 2) / len(x) #MSEmatrix = np.zeros((3 + 1, len(x)))matrix[3, :] = x ** 3matrix[2, :] = x ** 2matrix[1, :] = xmatrix[0, :] = 1reg = np.linalg.lstsq(matrix.T, f(x))[0]regry = np.dot(reg, matrix)plt.plot(x, f(x), 'b', label='f(x)')plt.plot(x, ry, 'r.', label='regression')plt.legend(loc=0)plt.grid(True)plt.xlabel('x')plt.ylabel('f(x)')matrix[3, :] = np.sin(x)reg = np.linalg.lstsq(matrix.T, f(x))[0]ry = np.dot(reg, matrix)plt.plot(x, f(x), 'b', label='f(x)')plt.plot(x, ry, 'r.', label='regression')plt.legend(loc=0)plt.grid(True)plt.xlabel('x')plt.ylabel('f(x)')np.allclose(f(x), ry)np.sum((f(x) - ry) ** 2) / len(x)#### INTERPOLATION ####import scipy.interpolate as spix = np.linspace(-2 * np.pi, 2 * np.pi, 25)def f(x):    return np.sin(x) + 0.5 * xipo = spi.splrep(x, f(x), k=1)iy = spi.splev(x, ipo)plt.plot(x, f(x), 'b', label='f(x)')plt.plot(x, iy, 'r.', label='interpolation')plt.legend(loc=0)plt.grid(True)plt.xlabel('x')plt.ylabel('f(x)')#### INTEGRATION ####import scipy.integrate as scidef f(x):    return np.sin(x) + 0.5 * xa = 0.5 # left integral limitb = 9.5 # right integral limitx = np.linspace(0, 10)y = f(x)from matplotlib.patches import Polygonfig, ax = plt.subplots(figsize=(7, 5))plt.plot(x, y, 'b', linewidth=2)plt.ylim(ymin=0)# area under the function# between lower and upper limitIx = np.linspace(a, b)Iy = f(Ix)verts = [(a, 0)] + list(zip(Ix, Iy)) + [(b, 0)]poly = Polygon(verts, facecolor='0.7', edgecolor='0.5')ax.add_patch(poly)# labelsplt.text(0.75 * (a + b), 1.5, r'$\int_a^b f(x)dx$', horizontalalignment='center', fontsize=20)plt.figtext(0.9, 0.075, '$x$')plt.figtext(0.075, 0.9, '$f(x)$')ax.set_xticks((a, b))ax.set_xticklabels(('$a$', '$b$'))ax.set_yticks([f(a), f(b)])